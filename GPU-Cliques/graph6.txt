            // DEGREE BASED PRUNING
            do
            {
            bool failed_found = false;
                // check for failed vertices
                for(int k = 0; k < number_of_new_vertices; k++){
                    if(!vert_isextendable_LU(new_vertices[k], number_of_new_vertices)){
                        failed_found = true;
                        break;
                    }
                }
                if(failed_found){
                    break;
                }

                // remove cands that do not meet the deg requirement
                number_of_removed_candidates = 0;
                for(int k = number_of_new_vertices; k < total_new_vertices; k++){
                    if(!cand_isvalid_LU(new_vertices[k], number_of_new_vertices)){
                        new_vertices[k].label = -1;
                        number_of_removed_candidates++;
                    }
                }
                qsort(new_vertices, total_new_vertices, sizeof(Vertex), sort_vertices);

                // update exdeg of vertices connected to removed cands
                for(int k = total_new_vertices - number_of_removed_candidates; k < total_new_vertices; k++){
                    pvertexid = new_vertices[k].vertexid;
                    pneighbors_start = graph.onehop_offsets[pvertexid];
                    pneighbors_end = graph.onehop_offsets[pvertexid + 1];
                    for(uint64_t l = pneighbors_start; l < pneighbors_end; l++){
                        int neighbor_of_removed_vertex = graph.onehop_neighbors[l];
                        int position_of_neighbor = linear_search_vertices(new_vertices, total_new_vertices, neighbor_of_removed_vertex);
                        if(position_of_neighbor != -1){
                            new_vertices[position_of_neighbor].exdeg--;
                        }
                    }
                    
                    // update lvl2adj
                    pneighbors_start = graph.twohop_offsets[pvertexid];
                    pneighbors_end = graph.twohop_offsets[pvertexid + 1];
                    for(uint64_t l = pneighbors_start; l < pneighbors_end; l++){
                        int neighbor_of_removed_vertex = graph.twohop_neighbors[l];
                        int position_of_neighbor = linear_search_vertices(new_vertices, total_new_vertices, neighbor_of_removed_vertex);
                        if(position_of_neighbor != -1){
                            new_vertices[position_of_neighbor].lvl2adj--;
                        }
                    }
                }
                total_new_vertices -= number_of_removed_candidates;
                number_of_new_candidates -= number_of_removed_candidates;
            }while(number_of_removed_candidates > 0);

            // continue if not enough vertices after pruning
            if(total_new_vertices < minimum_clique_size){
                continue;
            }

            // if vertex in x found as not extendable, check if current set is clique and continue to next iteration
            if(failed_found){
                if(number_of_members[warp_in_block_idx] >= (*device_data.minimum_clique_size)){
                    check_for_clique(number_of_members[warp_in_block_idx], lane_idx, warp_idx, vertices, wcliques_write, wcliques_offset_write, device_cliques, device_data);
                }
                continue;
            }